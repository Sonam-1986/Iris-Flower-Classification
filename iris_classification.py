# -*- coding: utf-8 -*-
"""Iris Classification

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I9lDaA49MMmuJ-uhry4KJHZDw6ceDSAB
"""

#!/usr/bin/env python3
"""
Iris classification demo script.

Saves plots under ./plots and trained models under ./models.
"""

import os
import warnings
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from joblib import dump

from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

PLOTS_DIR = "plots"
MODELS_DIR = "models"

os.makedirs(PLOTS_DIR, exist_ok=True)
os.makedirs(MODELS_DIR, exist_ok=True)

def load_as_dataframe():
    iris = datasets.load_iris()
    df = pd.DataFrame(iris.data, columns=iris.feature_names)
    df["target"] = iris.target
    df["target_name"] = df["target"].map(dict(enumerate(iris.target_names)))
    return df, iris

def eda(df):
    # Pairplot
    sns.set(style="ticks", context="notebook")
    pair = sns.pairplot(df, vars=df.columns[:4], hue="target_name", corner=True, plot_kws={"s": 30})
    pair.fig.suptitle("Iris pairplot", y=1.02)
    pair_path = os.path.join(PLOTS_DIR, "pairplot.png")
    pair.fig.savefig(pair_path, dpi=150, bbox_inches="tight")
    print(f"Saved pairplot to {pair_path}")

    # Histograms
    fig, axes = plt.subplots(2, 2, figsize=(10, 7))
    axes = axes.ravel()
    for i, col in enumerate(df.columns[:4]):
        sns.histplot(df[col], kde=True, ax=axes[i], color="tab:blue")
        axes[i].set_title(col)
    fig.tight_layout()
    hist_path = os.path.join(PLOTS_DIR, "histograms.png")
    fig.savefig(hist_path, dpi=150, bbox_inches="tight")
    plt.close(fig)
    print(f"Saved histograms to {hist_path}")

def train_and_evaluate(X_train, X_test, y_train, y_test, iris_target_names):
    models = {
        "logistic_regression": make_pipeline(StandardScaler(), LogisticRegression(max_iter=200)),
        "knn_k5": make_pipeline(StandardScaler(), KNeighborsClassifier(n_neighbors=5)),
        "decision_tree": DecisionTreeClassifier(random_state=42),
    }

    results = {}

    for name, model in models.items():
        print(f"\nTraining {name} ...")
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)
        report = classification_report(y_test, y_pred, target_names=iris_target_names, digits=4)
        cm = confusion_matrix(y_test, y_pred)

        # Save model
        model_path = os.path.join(MODELS_DIR, f"{name}.joblib")
        dump(model, model_path)
        print(f"Saved model to {model_path}")

        # Save confusion matrix plot
        fig, ax = plt.subplots(figsize=(5, 4))
        sns.heatmap(cm, annot=True, fmt="d", cmap="Blues", xticklabels=iris_target_names, yticklabels=iris_target_names, ax=ax)
        ax.set_xlabel("Predicted")
        ax.set_ylabel("True")
        ax.set_title(f"Confusion Matrix: {name} (acc={acc:.4f})")
        cm_path = os.path.join(PLOTS_DIR, f"confusion_{name}.png")
        fig.tight_layout()
        fig.savefig(cm_path, dpi=150, bbox_inches="tight")
        plt.close(fig)

        print(f"Saved confusion matrix to {cm_path}")
        print(f"Accuracy: {acc:.4f}")
        print("Classification report:")
        print(report)

        results[name] = {"accuracy": acc, "report": report, "confusion_matrix": cm, "model_path": model_path, "cm_path": cm_path}

    return results

def main():
    df, iris = load_as_dataframe()
    print("Dataset head:")
    print(df.head())

    # EDA
    eda(df)

    X = df.iloc[:, :4].values
    y = df["target"].values
    target_names = iris.target_names.tolist()

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42, stratify=y)
    print(f"\nTrain/Test sizes: {X_train.shape[0]} / {X_test.shape[0]}")

    results = train_and_evaluate(X_train, X_test, y_train, y_test, target_names)

    # Print summary
    print("\nSummary of accuracies:")
    for name, info in results.items():
        print(f"- {name}: {info['accuracy']:.4f}")

if __name__ == "__main__":
    main()